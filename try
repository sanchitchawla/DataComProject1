#! /usr/bin/python
# -*- coding: utf-8 -*-


import sys
import socket as soc 
import os
import asyncore
import logging
from urlparse import urlparse
from cStringIO import StringIO


def parse_url(url):
    DEFAULT_PORT=80
    parsed_url = urlparse(url)
    host, path, port = (parsed_url.hostname,
                        parsed_url.path,
                        parsed_url.port)
    if not port:
        port = DEFAULT_PORT
    return (host, path, port)

def sendstuff(socket, msg):     
    totalsent = 0     
    chunk = 8000     
    while totalsent < len(msg):             
        sent = socket.send(msg[totalsent:totalsent + chunk])   
        if sent == 0:
            raise RuntimeError("socket connection broken")                      
        totalsent = totalsent + sent

def recievestuff(socket):     
    bytesread = 0     
    packet = StringIO()     
    while True:                     
        chunk = socket.recv(2048)        
        if chunk == '':break         
        bytesread += len(chunk)                  
        packet.write(chunk)     
    return packet.getvalue()

def make_request(req_type, what, details, ver="1.1"):     
    NL = "\r\n"     
    req_line = "{verb} {w} HTTP/{v}".format(         
        verb=req_type, w=what, v=ver)     
    details = [         
    "{name}: {v}".format(name=n, v=v) for (n, v) in details.iteritems()
         ]     
    detail_lines = NL.join(details)     
    full_request = "".join([req_line, NL, detail_lines, NL, NL])     
    return full_request

def dicfunction(head):     
    mydic = dict()     
    header,body = head.split('\r\n\r\n')              
    bytes_head = len(header) + 4     
    eachhead = header.split('\r\n')     
    if "3" in eachhead[0]:
        print "redirect"
        #should implement redirect     
    for lines in eachhead[1:]:         
        field, value = lines.split(': ')         
        mydic[field] = value     
    return mydic

def connectme(HOST,PORT,PATH):
    socket=soc.socket(soc.AF_INET, soc.SOCK_STREAM)
    socket.connect((HOST,PORT)) 
    request = make_request(         
        'HEAD', PATH, {             
        'Host': HOST + ':' + str(PORT),             
        'Connection': 'close'}    
        )
    sendstuff(socket,request)
    response = recievestuff(socket)
    mydic = dicfunction(response)
    return mydic

def condition(Etag,conlength,lastMod):
    with open("meta.txt", 'r') as meta:
        read = meta.read()
        prev = extractdata(read)
        prevConlen = prev[0]
        prevLast = prev[1]
        prevEtag = prev[2]
    return prevConlen == conlength and prevLast == lastMod and prevEtag == ETag


def extractdata(header):
    haha = header.split("\r\n")
    prevCon,prevLast,prevEtag=" ", " ", " "
    for each in haha:
        try:
            if "Content-Length" in each:
                idc, prevCon = each.split(" ")
                print idc, prevCon
            if "Last-Modified" in each:
                idcc, prevLast = each.split(": ")
            if "ETag" in each:
                idccc, prevEtag = each.split(" ")
        except Exception as e:
            print "Server doesn't support resuming."
            sys.exit()
    return prevCon,prevLast,prevEtag


class HTTPClient(asyncore.dispatcher):
    ## Size of the buffer for each recv
    RECV_CHUNK_SIZE = 2048
 
    def __init__(self, url,filename,range=0, ContentLength=0, endbytes=0,resume=False):
        asyncore.dispatcher.__init__(self)
        self.HOST, self.PATH, self.PORT = parse_url(url)

        # Create a logger
        self.logger = logging.getLogger(url)
 
        # Create a TCP socket to host at the right port
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connect((host, port))

 
        # Create recv buffer and send buffer
        #(self.recvbuf, self.sendbuf) = (StringIO(), "")
 
        # Make an initial request & deliver it

        self.write(request)

        self.prevLast = ""
        self.prevConlen = 0
        self.prevEtag = ""
        
        self.headersend = ""
        self.resumesend = ""
        self.header = ""
        self.body = ""
        self.downloadedsofar = 0
        self.lastMod = ""
        self.conlength = 0
        self.ETag = ""
        self.url=""
        self.urled=""
 
    def write(self, data):
        """ Schedule to deliver data over the socket """
        self.sendbuf += data
 
    def handle_connect(self):
        self.logger.debug("Connected")
 
    def handle_close(self):
        self.logger.debug("Disconnected")
        self.close()
 
    def writeable(self):
        """ Check if there is anything to send """
        return len(self.sendbuf) > 0
 
    def handle_write(self):
        bytes_sent = self.send(self.sendbuf)
        self.sendbuf = self.sendbuf[bytes_sent:]
 
    def handle_read(self):
        text = ""
        recv = self.recv(2048)
        if not recv: return
        text += recv

        if "\r\n\r\n" in text:
            self.header, self.body = text.split("\r\n\r\n")
            prevstuff = self.extractdata(self.header)
            self.conlength = int(prevstuff[0])
            self.lastMod = prevstuff[1]
            self.ETag = prevstuff[2]
            info = '{}: {}\r\n{}: {}\r\n{}: {}\r\n'.format('Content-Length', self.conlength,
             'Last-Modified', self.lastMod, 'ETag', self.ETag)

        with open(self.filename + self.sanchit, 'wb+') as file, open("meta.txt", 'w') as metafile:

            file.write(self.body)
            size = len(self.body)
            metafile.write(info)
            while size < self.conlength:

                recv = self.socket.recv(2048)
                size += len(recv)
                file.write(recv)
                metafile.write('{}\r\n'.format(size))
                if not recv: break


                percent = "{0:.2f}".format(
                (size / float(self.conlength)) * 100.0)
                fill = int(
                    round(50 * (size / float(self.conlength))))
                bar = 'â–ˆ' * fill + '-' * (50-fill)
                sys.stdout.write('\rProgress |%s| - %s%s ' % (bar, percent, '%'))
                sys.stdout.flush()


        os.renames(self.filename + self.sanchit, self.filename)
        print "Complete"
        os.remove("meta.txt")
        self.socket.close()
        sys.exit()


    def sendheader(self):
        self.headersend = "GET " + self.connect_path + " HTTP/1.1\r\n" + "Host: " + self.HOST + "\r\n\r\n"
        self.write(self.headersend)

    def sendresumeheader(self):
        self.resumesend = "GET " + self.connect_path + " HTTP/1.1\r\n" + "Host: " + self.HOST +\
         "\r\nRange: bytes=" + str(self.downloadedsofar) + "-" + "\r\n\r\n"
        self.write(self.resumesend) 
 
if __name__ == "__main__":
    filename = sys.argv[2]
    url = sys.argv[-1]
    num= sys.argv[4]
    urled= urlparse(url)
    HOST = urled.hostname
    PATH = urled.path
    PORT = urled.port
    if PORT==None:
        PORT=80
    if PATH == None or PATH == "":
        PATH = "/"
    mydic= connectme(HOST,PORT,PATH)
    Etag = mydic["ETag"]
    LastMod= mydic["Last-Modified"]
    ContentLength= int(mydic["Content-Length"])
    print Etag,LastMod,ContentLength
    if os.path.isfile(filename + "sanchit"):
        downloadedsofar = os.path.getsize(filename + "sanchit")
        if condition(Etag,ContentLength,LastMod):
            #resume
        else:
            print "Files are changed."
            sys.exit(2)

    else: 
        async=[]
        for i in range(num):
            async+= HTTPClient(url,str(i)+ filename, range=(i*ContentLength)/num,
                     ContentLength= ContentLength,endbytes= ((i+1)* ContentLength)/num)
        async+=HTTPClient(url,str(num-1)+filename, range= ((num-1)*ContentLength)/ num,
                    ContentLength=ContentLength, endbytes= ContentLength)
        asyncore.loop()
        